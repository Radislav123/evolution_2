## Производительность

1) Numba @njit(parallel=True)

### Оптимизации

1) Посмотреть, какие блоки gpu недозадействованы, и переложить часть работы на них.
2) Записывать все уровни в одну текстуру, но разбить глобальную текстуру на чанки
    1) Сейчас при обработке нескольких уровней гарантировано идут промахи кэша, так как данные берутся из разных текстур. Такая реорганизация позволит
       радикально сократить промахи кэша.


## Существа
### Реализация
Реализовать полностью на GPU.

Пример реализации:

```glsl
struct Creature {
    vec3 position;
    vec3 velocity;
    uint type;
    float health;
    uint target_voxel;
};

layout(std430, binding = 5) buffer Creatures {
    Creature u_creatures[];
};
```

### Нейроны и нейронная сеть

1) Реализовать на gpu через "связанную сеть" - у каждого нейрона есть входы и веса на этих входах;
2) Входы - ссылки на другие нейроны или сенсоры;
3) Каждый тик обрабатывается вся сеть, но только на один шаг вперед;
    1) К примеру, сеть состоит из 3 нейронов. Значит 3-й не получит информации от 1-го в первый тик, а только от 2-го. до 3-го информация от 1-го дойдет только
       на второй тик;
    2) Для этого сеть необходимо обрабатывать, начиная с выходов;


## Упаковка данных
Одна текстура на канал в ячейке. То есть если в мире в каждой ячейке может быть до 4 веществ, держать 4 текстуры. Текстура в формате GL_RGBA32UI.

Пример упаковки по каналам:

1) (0-15) id, (16-31) quantity
2) (0-9, 10-19, 20-29) force_vector, (30) flag_0, (31) flag_1
3) (0-15) id существа, (16-31) something_0
4) (0-31) something_1

Флаги:

1) flag_0 - указывает на наличие следующего вещества в вокселе. Если значение == 1, читаем из следующей текстуры, если == 0, не читаем.

## Химические реакции
Можно начать с того, что описано ниже. Заводится 2д-текстура с размерами NxN, где N - количество веществ в мире. В ячейке с координатами (I, J) лежит реакция
этих двух веществ. Вероятно, реакции с большим количеством веществ и не нужны.
